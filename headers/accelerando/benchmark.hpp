// Copyright 2017 Kyle Mayes
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ACCEL_BENCHMARK_HPP
#define ACCEL_BENCHMARK_HPP

#include <chrono>
#include <cstdint>
#include <type_traits>
#include <vector>

namespace accel {

/// An amount of time represented as a quantity of nanoseconds.
template <class T>
using Nanoseconds = std::chrono::duration<T, std::nano>;

/// A sample taken by repeatedly executing a benchmark function.
struct Sample {
    /// The number of times the benchmark function was executed.
    uint64_t iterations;
    /// The total amount of time spent executing the benchmark function.
    Nanoseconds<uint64_t> duration;
    /// The average amount of time spent executing each iteration of the benchmark function.
    Nanoseconds<double> average;

    /// Constructs a benchmark sample.
    Sample(uint64_t iterations, Nanoseconds<uint64_t> duration);
};

/// An ordinary least squares (OLS) linear regression.
struct LinearRegression {
    /// The y-intercept.
    Nanoseconds<double> b0;
    /// The slope.
    Nanoseconds<double> b1;
    /// The goodness of fit.
    double r2;

    /// Calculates and constructs an OLS linear regression.
    LinearRegression(const std::vector<Sample>& samples);
};

/// A report generated by running a benchmark.
struct BenchmarkReport {
    /// The samples collected.
    std::vector<Sample> samples;
    /// The average of the sample averages.
    Nanoseconds<double> mean;
    /// The standard deviation of the sample averages.
    Nanoseconds<double> stddev;
    /// The OLS linear regression calculated with the sample iterations as the explanatory variable
    /// and the sample averages as the dependent variable.
    LinearRegression ols;

    /// Constructs a benchmark report.
    BenchmarkReport(std::vector<Sample> samples);
};

/// A benchmark.
class Benchmark {
public:
    /// Called once before any instances of this benchmark are executed.
    static void static_set_up() { }
    /// Called once after all instances of this benchmark have been executed.
    static void static_tear_down() { }

    /// Constructs a benchmark.
    Benchmark() = default;

    virtual ~Benchmark() = default;

    /// Called once before each instance of this benchmark is executed.
    virtual void set_up() { }
    /// Called once after each instance of this benchmark is executed.
    virtual void tear_down() { }

    /// Executes this benchmark for the supplied time limit and returns a report.
    BenchmarkReport run(Nanoseconds<uint64_t> limit);

protected:
    /// The user-supplied benchmark function.
    virtual void execute() = 0;
};

// The implementations of `retain()` below are based on the implementations of `doNotOptimizeAway()`
// in Facebook's `folly` library (https://github.com/facebook/folly).

#ifdef _MSC_VER
namespace detail {
    #pragma optimize("", off)
    inline void sink(const void*) { }
    #pragma optimize("", on)
}

/// Prevents the optimizer from removing the computation of the supplied value.
template <class T>
void retain(T& value) {
    detail::sink(&value)
}

/// Prevents the optimizer from removing the computation of the supplied value.
template <class T>
void retain(const T& value) {
    detail::sink(&value);
}
#else
namespace detail {
    /// Whether values of the provided type parameter can and should be stored in a register to
    /// force the computation of the value.
    template <class T>
    constexpr static auto REGISTER =
        // The type needs to actually fit in a register.
        sizeof(std::decay_t<T>) <= sizeof(long) &&
        // The type needs to be trivially copyable so the compiler will be willing to store values
        // of the type in a register.
        std::is_trivially_copyable_v<T> &&
        // The type shouldn't be a pointer because storing a pointer in a register won't actually
        // force the computation of the value the pointer refers to which could be confusing.
        !std::is_pointer_v<std::decay_t<T>>;
}

/// Prevents the optimizer from removing the computation of the supplied value.
template <class T, std::enable_if_t<detail::REGISTER<T>, int> = 0>
void retain(const T& value) {
    // Force the compiler to store `value` in a register.
    asm volatile("" :: "r"(value));
}

/// Prevents the optimizer from removing the computation of the supplied value.
template <class T, std::enable_if_t<!detail::REGISTER<T>, int> = 0>
void retain(const T& value) {
    // Notify the compiler that we will read `value` from memory and potentially read and write from
    // any other memory locations.
    asm volatile("" :: "m"(value) : "memory");
}
#endif

}

#endif
