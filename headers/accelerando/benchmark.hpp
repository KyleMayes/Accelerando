// Copyright 2017 Kyle Mayes
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ACCEL_BENCHMARK_HPP
#define ACCEL_BENCHMARK_HPP

#include <chrono>
#include <cstdint>
#include <vector>

namespace accel {

/// An amount of time represented as a quantity of nanoseconds.
template <class T>
using Nanoseconds = std::chrono::duration<T, std::nano>;

/// A sample taken by repeatedly executing a benchmark function.
struct Sample {
    /// The number of times the benchmark function was executed.
    uint64_t iterations;
    /// The total amount of time spent executing the benchmark function.
    Nanoseconds<uint64_t> duration;
    /// The average amount of time spent executing each iteration of the benchmark function.
    Nanoseconds<double> average;

    /// Constructs a benchmark sample.
    Sample(uint64_t iterations, Nanoseconds<uint64_t> duration);
};

/// An ordinary least squares (OLS) linear regression.
struct LinearRegression {
    /// The y-intercept.
    Nanoseconds<double> b0;
    /// The slope.
    Nanoseconds<double> b1;
    /// The goodness of fit.
    double r2;

    /// Calculates and constructs an OLS linear regression.
    LinearRegression(const std::vector<Sample>& samples);
};

/// A report generated by running a benchmark.
struct BenchmarkReport {
    /// The samples collected.
    std::vector<Sample> samples;
    /// The average of the sample averages.
    Nanoseconds<double> mean;
    /// The standard deviation of the sample averages.
    Nanoseconds<double> stddev;
    /// The OLS linear regression calculated with the sample iterations as the explanatory variable
    /// and the sample averages as the dependent variable.
    LinearRegression ols;

    /// Constructs a benchmark report.
    BenchmarkReport(std::vector<Sample> samples);
};

/// A benchmark.
class Benchmark {
public:
    /// Called once before any instances of this benchmark are executed.
    static void static_set_up() { }
    /// Called once after all instances of this benchmark have been executed.
    static void static_tear_down() { }

    /// Constructs a benchmark.
    Benchmark() = default;

    virtual ~Benchmark() = default;

    /// Called once before each instance of this benchmark is executed.
    virtual void set_up() { }
    /// Called once after each instance of this benchmark is executed.
    virtual void tear_down() { }

    /// Executes this benchmark for the supplied time limit and returns a report.
    BenchmarkReport run(Nanoseconds<uint64_t> limit);

protected:
    /// The user-supplied benchmark function.
    virtual void execute() = 0;
};

}

#endif
