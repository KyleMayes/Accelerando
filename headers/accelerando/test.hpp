// Copyright 2017 Kyle Mayes
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ACCEL_TEST_HPP
#define ACCEL_TEST_HPP

#include <cstdint>
#include <optional>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

namespace accel {

/// A location in a source file.
struct Location {
    /// The name of the source file.
    const char* file;
    /// The line in the source file.
    uint64_t line;

    /// Constructs a location.
    Location(const char* file, uint64_t line);
};

/// An assertion failure.
struct Failure {
    /// The location stack of the failed assertion.
    std::vector<Location> stack;
    /// The failed assertion.
    std::string assertion;
    /// The message provided by the failed assertion, if any.
    std::optional<std::string> message;
    /// Additional information provided by the failed assertion.
    std::vector<std::pair<std::string, std::string>> information;

    /// Constructs an assertion failure.
    Failure(Location location, std::string assertion);

    /// Appends the supplied argument to the message for this assertion failure.
    template <class T>
    Failure& operator<<(const T& value) {
        std::stringstream ss;
        ss << value;
        if (message) {
            message->append(ss.str());
        } else {
            message = ss.str();
        }
        return *this;
    }

    /// Adds a key-value pair to the information for this assertion failure.
    void add_information(std::string key, std::string value);
};

/// A report generated by running a test.
struct TestReport {
    /// The assertion failures encountered.
    std::vector<Failure> failures;

    /// Constructs a test report.
    TestReport(std::vector<Failure> failures);
};

class Registry;

/// A test.
class Test {
    friend class Registry;

    Location location{"", 0};

public:
    /// Called once before any instances of this test are executed.
    static void static_set_up() { }
    /// Called once after all instances of this test have been executed.
    static void static_tear_down() { }

    /// Constructs a test.
    Test() = default;

    virtual ~Test() = default;

    /// Called once before each instance of this test is executed.
    virtual void set_up() { }
    /// Called once after each instance of this test is executed.
    virtual void tear_down() { }

    /// Executes this test and returns a report.
    TestReport run();

protected:
    /// The user-supplied test function.
    virtual void execute(std::vector<Failure>& failures) = 0;
};

}

#endif
